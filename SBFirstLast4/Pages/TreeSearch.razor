@page "/treesearch"
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@using SBFirstLast4.Expression

<div id="pagemain">
	<div class="tree-node">
		<div class="node-title">
			ソース
		</div>
		<select class="dropdown">
			<option>無属性辞書</option>
			<option>有属性辞書</option>
		</select>
	</div>
	@foreach (var (node, index) in Nodes.WithIndex())
	{
		var nodeName = node.Type;
		@if (index == 0)
		{
			<div class="pipe" />
			node.Pipe = Pipe.None;
		}
		else
		{
			node.Pipe = Pipe.And;
			<div id="pipe-@index-upper" class="pipe" style="background-color: olivedrab" />
			<select id="join-selector-@index" class="join-selector" style="background-color: olivedrab" @onchange=@(async _ =>
			{
			var value = await JSRuntime.GetElementValueById<string>($"join-selector-{index}");
			var color = value switch
			{
			"AND" => "olivedrab",
			"OR" => "darkmagenta",
			"XOR" => "cadetblue",
			"NAND" => "indianred",
			"NOR" => "dimgray",
			"XNOR" => "limegreen",
			"IMPLY" => "darkgoldenrod",
			"NIMPLY" => "steelblue",
			_ => "lightgray"
			};
			node.Pipe = Enum.TryParse<Pipe>(value, true, out var pipe) ? pipe : Pipe.And;
			await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('#join-selector-{index}').style.backgroundColor = '{color}'");
			await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('#pipe-{index}-upper').style.backgroundColor = '{color}'");
			await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('#pipe-{index}-lower').style.backgroundColor = '{color}'");
			StateHasChanged();
			await Task.Delay(1);
			})>
				@foreach (var i in new[] { "AND", "OR", "XOR", "NAND", "NOR", "XNOR", "IMPLY", "NIMPLY" })
				{
					<option value="@i" style="background-color: whitesmoke; color: black;">@i</option>
				}
			</select>
			<div id="pipe-@index-lower" class="pipe" style="background-color: olivedrab" />
		}
		<div class="tree-node">
			<div style="display: grid; grid-template-columns: 40%; align-items: center; justify-items: center;">
				<select id="aff-neg-selector-@index" class="aff-neg-selector" style="background-color: darkcyan" 　@onchange=@(async _ =>
					{
					var value = await JSRuntime.GetElementValueById<string>($"aff-neg-selector-{index}");
					var color = value switch
					{
					"ID" => "darkcyan",
					"NOT" => "darkred",
					_ => "lightgray"
					};
					node.IsIdentity = value == "ID";
					await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('#aff-neg-selector-{index}').style.backgroundColor = '{color}'");
					StateHasChanged();
					await Task.Delay(1);
					})>
					@foreach (var i in new[] { "ID", "NOT" })
					{
						<option value="@i" style="background-color: whitesmoke; color: black;">@i</option>
					}
				</select>
				<div class="node-title" style="grid-column: 1/3; grid-row: 1/2">
					@nodeName
				</div>
			</div>
			<div style="display: flex; flex-flow: row; justify-content: center; align-items: center; column-gap: 15px;">
				@switch (nodeName)
				{
					case NodeType.First when node is FirstNode firstNode:
						<input class="text-box" type="text" maxlength="1" />
						<div style="text-align: center; font-family: 'M PLUS 1';">と</div>
						<select class="dropdown" style="width: 130px;" @onchange=@(e => firstNode.IsEqual = e.Value as string == "等しい")>
							@foreach (var i in new[] { "等しい", "等しくない" })
							{
								<option value="@i">@i</option>
							}
						</select>
						break;
					case NodeType.Last when node is LastNode lastNode:
						<input class="text-box" type="text" maxlength="1" />
						<div style="text-align: center; font-family: 'M PLUS 1';">と</div>
						<select class="dropdown" style="width: 130px;" @onchange=@(e => lastNode.IsEqual = e.Value as string == "等しい")>
							@foreach (var i in new[] { "等しい", "等しくない" })
							{
								<option value="@i">@i</option>
							}
						</select>
						break;
					case NodeType.Length when node is LengthNode lengthNode:
						<input class="text-input" type="text" maxlength="3" style="width: 20%;" />
						<div style="text-align: center; font-family: 'M PLUS 1'; font-size: 18px;">文字</div>
						<select class="dropdown" style="width: 130px;" @onchange="e => lengthNode.Attribute = e.Value as string ?? LengthAttribute.GreaterOrEqualTo">
							@foreach (var i in LengthAttribute.Attributes)
							{
								<option value="@i">@i</option>
							}
						</select>
						break;
					case NodeType.Type when node is TypeNode typeNode:
						<select class="dropdown" style="width: max(92px, 20%); padding: 5px;" @onchange="e => typeNode.WordType = (e.Value as string)?.StringToType() ?? default">
							@foreach (var i in new[] { "ノーマル", "動物", "植物", "地名", "感情", "芸術", "食べ物", "暴力", "医療", "人体", "機械", "理科", "時間", "人物", "工作", "服飾", "社会", "遊び", "虫", "数学", "暴言", "宗教", "スポーツ", "天気", "物語" })
							{
								<option value="@i">@i</option>
							}
						</select>
						<select class="dropdown" style="width: max(60px, 18%); font-size: 16px; padding: 5px;">
							@foreach (var i in new[] { "を", "以外を" })
							{
								<option value="@i">@i</option>
							}
						</select>
						<select class="dropdown" style="width: max(92px, 20%); padding: 5px;">
							@foreach (var i in new[] { "含む", "含まない" })
							{
								<option value="@i">@i</option>
							}
						</select>
						break;
					case NodeType.Regex when node is RegexNode regexNode:
						<input class="text-input" type="text" style="width: 60%;" />
						<div style="text-align: center; font-family: 'M PLUS 1';">とマッチ</div>
						break;
					default:
						break;
				}
			</div>
		</div>
	}
	<div class="pipe"></div>
	<div class="tree-node" style="align-self: start; margin-left: 27px; width: 200px;">
		<select id=node-selector class="dropdown" style="font-size: 17px;" @onchange=@(async e =>
				{
				var value = await JSRuntime.GetElementValueById<string>("node-selector");
				Nodes.Add(Node.Create(value));
				await JSRuntime.SetElementValueById("node-selector", "root");
				StateHasChanged();
				})>
			<option disabled hidden selected value="root">ノードの追加</option>
			@foreach (var i in NodeType.Types)
			{
				<option value="@i">@i</option>
			}
		</select>
	</div>
	<button class="search-button" @onclick=SearchButton_Click>単語を検索</button>
</div>

<style>
	@@import url('https://fonts.googleapis.com/css?family=M+PLUS+1p');
	@@import url('https://fonts.googleapis.com/css?family=Sawarabi+Gothic');

	body {
		background-color: #F5F6F1;
	}

	#pagemain {
		display: flex;
		flex-flow: column;
		align-content: center;
	}

	.tree-node {
		display: flex;
		border-radius: 20px;
		background-color: white;
		box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
		margin: 20px;
		flex-flow: column;
	}

	.node-title {
		font-size: 21px;
		font-weight: bold;
		align-self: center;
		margin-top: 10px;
		margin-bottom: 3px;
	}

	#source-selector {
		align-self: center;
	}

	.pipe {
		margin-left: 50px;
		width: 10px;
		height: 60px;
		margin-top: -20px;
		margin-bottom: -20px;
		background-color: lightgray;
	}



	.join-selector {
		-moz-appearance: none;
		-webkit-appearance: none;
		z-index: 2;
		width: 150px;
		border-radius: 5px;
		border-color: transparent;
		font-family: 'Sawarabi Gothic';
		text-align: center;
		font-weight: bold;
		font-size: 20px;
		color: white;
		margin-left: 50px;
	}

		.join-selector::-ms-expand {
			display: none;
		}

	.aff-neg-selector {
		-moz-appearance: none;
		-webkit-appearance: none;
		width: max(60px, 45%);
		grid-column: 1/2;
		grid-row: 1/2;
		border-radius: 5px;
		border-color: transparent;
		font-family: 'Sawarabi Gothic';
		text-align: center;
		font-weight: bold;
		font-size: 18px;
		color: white;
	}

		.aff-neg-selector::-ms-expand {
			display: none;
		}

	.text-box {
		width: 60px;
		height: 60px;
		display: flex;
		align-self: center;
		justify-content: center;
		align-items: center;
		text-align: center;
		border: 2px solid gray;
		border-radius: 10px;
		font-size: 22px;
		background-color: white;
		box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
		margin-top: 15px;
		margin-bottom: 15px;
	}

	.text-input {
		width: 80%;
		padding: 12px;
		align-self: center;
		font-size: 18px;
		border: 2px solid gray;
		border-radius: 5px;
		margin-top: 15px;
		margin-bottom: 15px;
	}

	.dropdown {
		-moz-appearance: none;
		-webkit-appearance: none;
		width: 80%;
		padding: 12px;
		font-size: 18px;
		border: 2px solid gray;
		border-radius: 5px;
		margin-top: 15px;
		margin-bottom: 15px;
		align-self: center;
	}

		.dropdown::-ms-expand {
			display: none;
		}

	.search-button {
		align-self: center;
		text-align: center;
		width: 92%;
		line-height: 60px;
		font-weight: bold;
		height: 60px;
		border: none;
		border-radius: 30px;
		font-size: 24px;
		cursor: pointer;
		background: linear-gradient(to right, #2524c0, #f035cb);
		color: white;
		transition: background-color 0.3s, color 0.3s;
		text-decoration: none;
		margin-top: 20px;
		margin-bottom: 30px;
	}

</style>
@code {

	List<Node> Nodes = new();

	protected override void OnInitialized()
	{
		if (!AppSettings.IsLoggedIn)
		{
			NavigationManager.NavigateTo("", false);
			return;
		}
		if (!Words.IsLoadedCorrectly)
			NavigationManager.NavigateTo("top", false);
	}

	private void SearchButton_Click()
	{
		var predicates = new List<Func<Word, bool>> { _ => true };
		foreach(var (node, index) in Nodes.WithIndex())
		{
			switch (node)
			{
				case FirstNode firstNode:
					predicates.Add(w => firstNode.IsIdentity && firstNode.IsEqual ? w.Start == firstNode.Value
									  : !firstNode.IsIdentity && firstNode.IsEqual ? w.Start != firstNode.Value
									  : firstNode.IsIdentity && !firstNode.IsEqual ? w.Start != firstNode.Value
									  : w.Start == firstNode.Value);
					continue;

				case LastNode lastNode:
					continue;

				case LengthNode lengthNode:
					continue;

				case TypeNode typeNode:
					continue;

				case RegexNode regexNode:
					continue;

				default:
					continue;
			}
		}
	}
}
